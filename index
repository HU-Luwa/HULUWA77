import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.spatial import distance, Voronoi
import folium
from folium.plugins import HeatMap, MarkerCluster
import webbrowser
import os
import random
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection
from matplotlib.path import Path
import matplotlib.cm as cm

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==================== 数据准备 ====================
def generate_data(n_cities=50, seed=42):
    np.random.seed(seed)
    random.seed(seed)

    data = {
        '城市序号': range(1, n_cities + 1),
        'x坐标': np.random.randint(0, 100, n_cities),
        'y坐标': np.random.randint(0, 100, n_cities),
        '供需量': np.random.randint(10, 100, n_cities),
        '仓库成本': np.random.randint(50000, 200000, n_cities),
        '物流系数': np.round(np.random.uniform(0.8, 1.5, n_cities), 2)
    }
    return pd.DataFrame(data)


# ==================== 蚁群优化算法 ====================
class EnhancedACO:
    def __init__(self, dist_matrix, demands, warehouse_costs, logistics_factors,
                 n_centers=5, n_ants=20, max_iter=100,
                 alpha=1, beta=2, rho=0.1, q0=0.7):
        self.dist_matrix = dist_matrix
        self.demands = demands
        self.warehouse_costs = warehouse_costs
        self.logistics_factors = logistics_factors
        self.n_nodes = len(dist_matrix)
        self.n_centers = n_centers
        self.n_ants = n_ants
        self.max_iter = max_iter
        self.alpha = alpha  # 信息素重要程度
        self.beta = beta  # 启发式信息重要程度
        self.rho = rho  # 信息素挥发系数
        self.q0 = q0  # 直接选择概率

        # 初始化信息素矩阵
        self.pheromone = np.ones((self.n_nodes, self.n_nodes)) / self.n_nodes
        self.best_solution = None
        self.best_cost = float('inf')

    def _calculate_cost(self, solution):
        if len(solution) != self.n_centers:
            return float('inf')

        nearest_centers = np.argmin(self.dist_matrix[:, solution], axis=1)
        total_cost = 0

        for idx, center in enumerate(solution):
            served_nodes = np.where(nearest_centers == idx)[0]
            if len(served_nodes) == 0:
                return float('inf')

            transport_cost = np.sum(
                self.demands[served_nodes] *
                np.min(self.dist_matrix[:, solution], axis=1)[served_nodes] *
                self.logistics_factors[center]
            )
            total_cost += transport_cost + self.warehouse_costs[center]

        return total_cost

    def run(self):
        convergence_curve = []

        for iteration in range(self.max_iter):
            solutions = []
            costs = []

            for ant in range(self.n_ants):
                # 构建解
                allowed = list(range(self.n_nodes))
                solution = []

                while len(solution) < self.n_centers and len(allowed) > 0:
                    if len(solution) == 0:
                        # 初始随机选择
                        next_node = random.choice(allowed)
                    else:
                        # 计算转移概率
                        tau = self.pheromone[solution[-1], allowed] ** self.alpha
                        eta = (1 / (self.dist_matrix[solution[-1], allowed] + 1e-10)) ** self.beta
                        prob = tau * eta
                        prob /= prob.sum()

                        # 轮盘赌或直接选择
                        if random.random() < self.q0:
                            next_node = allowed[np.argmax(prob)]
                        else:
                            next_node = np.random.choice(allowed, p=prob)

                    solution.append(next_node)
                    allowed.remove(next_node)

                # 评估解
                cost = self._calculate_cost(solution)
                solutions.append(solution)
                costs.append(cost)

                # 更新最优解
                if cost < self.best_cost:
                    self.best_solution = solution.copy()
                    self.best_cost = cost

            # 更新信息素
            self.pheromone *= (1 - self.rho)  # 信息素挥发

            # 只允许最优蚂蚁释放信息素
            best_idx = np.argmin(costs)
            for i in range(len(solutions[best_idx]) - 1):
                from_node = solutions[best_idx][i]
                to_node = solutions[best_idx][i + 1]
                self.pheromone[from_node, to_node] += 1.0 / costs[best_idx]

            convergence_curve.append(self.best_cost)

            # 打印进度
            if (iteration + 1) % 10 == 0:
                print(f"Iteration {iteration + 1}/{self.max_iter}, Best Cost: {self.best_cost:,.2f}")

        return self.best_solution, self.best_cost, convergence_curve


# ==================== 可视化函数 ====================
def plot_convergence(convergence):
    plt.figure(figsize=(10, 6))
    plt.plot(convergence, 'b-', linewidth=2)
    plt.xlabel('迭代次数')
    plt.ylabel('总成本')
    plt.title('蚁群算法收敛曲线')
    plt.grid(True)
    plt.show()


def plot_location_map(df, result, dist_matrix):
    plt.figure(figsize=(12, 8))

    # 绘制所有城市
    plt.scatter(df['x坐标'], df['y坐标'],
                s=df['供需量'] / 2, c='blue',
                alpha=0.6, label='需求点')

    # 绘制配送中心
    plt.scatter(result['x坐标'], result['y坐标'],
                s=100, c='red', marker='s',
                edgecolors='black', label='配送中心')

    # 绘制服务区域（Voronoi图）
    points = result[['x坐标', 'y坐标']].values
    vor = Voronoi(points)

    # 绘制Voronoi边
    for simplex in vor.ridge_vertices:
        simplex = np.asarray(simplex)
        if np.all(simplex >= 0):
            plt.plot(vor.vertices[simplex, 0],
                     vor.vertices[simplex, 1], 'k--', alpha=0.4)

    # 添加标签
    for i, row in result.iterrows():
        plt.annotate(f"#{row['城市序号']}\n成本:{row['服务总成本'] / 10000:.1f}万",
                     (row['x坐标'], row['y坐标']),
                     textcoords="offset points", xytext=(0, 10),
                     ha='center', fontsize=8)

    plt.xlabel('X坐标')
    plt.ylabel('Y坐标')
    plt.title('配送中心选址与服务区域划分')
    plt.legend()
    plt.grid(True)
    plt.show()


def plot_radar_chart(result):
    categories = [f"中心#{i}" for i in result['城市序号']]
    labels = np.array(categories)

    # 标准化数据
    norm_cost = result['服务总成本'] / result['服务总成本'].max()
    norm_demand = result['供需量'] / result['供需量'].max()
    norm_coverage = result['服务城市数'] / result['服务城市数'].max()

    angles = np.linspace(0, 2 * np.pi, len(categories), endpoint=False)
    fig = plt.figure(figsize=(8, 8))
    ax = fig.add_subplot(111, polar=True)

    # 绘制三条线
    ax.plot(angles, norm_cost, 'o-', label='相对成本')
    ax.plot(angles, norm_demand, 'o-', label='相对需求')
    ax.plot(angles, norm_coverage, 'o-', label='相对覆盖')

    ax.fill(angles, norm_cost, alpha=0.1)
    ax.fill(angles, norm_demand, alpha=0.1)
    ax.fill(angles, norm_coverage, alpha=0.1)

    ax.set_thetagrids(angles * 180 / np.pi, labels)
    ax.set_title('配送中心性能雷达图', pad=20)
    ax.legend(loc='upper right', bbox_to_anchor=(1.1, 1.1))
    plt.show()


def plot_cost_breakdown(result):
    fig, ax = plt.subplots(figsize=(10, 6))

    # 计算成本构成
    transport_cost = result['服务总成本'] - result['仓库成本']

    # 堆叠条形图
    p1 = ax.bar(result['城市序号'], result['仓库成本'], label='仓库成本')
    p2 = ax.bar(result['城市序号'], transport_cost, bottom=result['仓库成本'],
                label='运输成本')

    ax.set_xlabel('配送中心编号')
    ax.set_ylabel('成本 (万元)')
    ax.set_title('配送中心成本构成分析')
    ax.legend()

    # 修正后的标签添加逻辑
    for rect in p1.patches + p2.patches:  # 使用.patches访问所有矩形
        height = rect.get_height()
        bottom = rect.get_y()
        ax.text(rect.get_x() + rect.get_width() / 2., bottom + height / 2,
                f'{height / 10000:.1f}万',
                ha='center', va='center', fontsize=8)

    plt.xticks(result['城市序号'])
    plt.grid(axis='y', alpha=0.3)
    plt.show()


def plot_map_with_folium(df, result, dist_matrix):
    # 计算中心点
    center_lat, center_lon = df['y坐标'].mean() / 100, df['x坐标'].mean() / 100

    # 创建地图（坐标缩放100倍模拟经纬度）
    m = folium.Map(location=[center_lat, center_lon],
                   zoom_start=11,
                   tiles='https://webst02.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}',
                   attr='高德地图')

    # 添加热力图（需求密度）
    heat_data = [[row['y坐标'] / 100, row['x坐标'] / 100, row['供需量']]
                 for _, row in df.iterrows()]
    HeatMap(heat_data, radius=15, blur=10,
            gradient={0.4: 'blue', 0.6: 'lime', 1: 'red'}).add_to(m)

    # 添加需求点标记
    mc = MarkerCluster()
    for _, row in df.iterrows():
        popup_text = f"""
        <b>城市#{row['城市序号']}</b><br>
        坐标: ({row['x坐标']}, {row['y坐标']})<br>
        需求量: {row['供需量']}吨<br>
        仓库成本: ¥{row['仓库成本']:,}
        """
        mc.add_child(
            folium.CircleMarker(
                location=[row['y坐标'] / 100, row['x坐标'] / 100],
                radius=row['供需量'] / 10,
                popup=popup_text,
                color='#3186cc',
                fill=True,
                fill_opacity=0.7
            )
        )
    m.add_child(mc)

    # 添加配送中心标记
    for _, row in result.iterrows():
        # 计算服务区域
        nearest_centers = np.argmin(dist_matrix[:, result.index], axis=1)
        served_nodes = np.where(nearest_centers == np.where(np.array(result.index) == row.name)[0][0])[0]

        folium.Marker(
            location=[row['y坐标'] / 100, row['x坐标'] / 100],
            popup=f"""
            <b>配送中心#{row['城市序号']}</b><br>
            服务城市: {len(served_nodes)}个<br>
            总成本: ¥{row['服务总成本']:,}<br>
            <button onclick="alert('服务城市: {df.iloc[served_nodes]['城市序号'].tolist()}')">
            查看详情</button>
            """,
            icon=folium.Icon(
                color='red',
                icon='warehouse',
                prefix='fa'
            )
        ).add_to(m)

        # 绘制服务范围（泰森多边形）
        points = [[p[1] / 100, p[0] / 100] for p in result[['x坐标', 'y坐标']].values]
        vor = Voronoi(points)
        lines = [
            [(points[i][0], points[i][1]), (points[j][0], points[j][1])]
            for i, j in vor.ridge_vertices if i >= 0 and j >= 0
        ]
        folium.PolyLine(
            locations=lines,
            color='orange',
            weight=2,
            opacity=0.6
        ).add_to(m)

    # 保存并自动打开地图
    map_path = 'delivery_centers_map.html'
    webbrowser.open('file://' + os.path.realpath(map_path))
    return m


# ==================== 主程序 ====================
if __name__ == '__main__':
    # 1. 生成模拟数据
    df = generate_data(n_cities=50, seed=42)

    # 2. 计算距离矩阵
    coordinates = df[['x坐标', 'y坐标']].values
    dist_matrix = distance.cdist(coordinates, coordinates, 'euclidean')

    # 3. 运行优化算法
    aco = EnhancedACO(
        dist_matrix=dist_matrix,
        demands=df['供需量'].values,
        warehouse_costs=df['仓库成本'].values,
        logistics_factors=df['物流系数'].values,
        n_centers=6,
        n_ants=50,
        max_iter=200
    )

    best_solution, best_cost, convergence = aco.run()

    # 4. 准备结果数据
    result = df.iloc[best_solution].copy()
    service_costs = []
    service_counts = []

    nearest_centers = np.argmin(dist_matrix[:, best_solution], axis=1)
    for c in best_solution:
        served_nodes = np.where(nearest_centers == np.where(np.array(best_solution) == c)[0][0])[0]
        transport_cost = np.sum(
            df['供需量'].values[served_nodes] *
            np.min(dist_matrix[:, best_solution], axis=1)[served_nodes] *
            df['物流系数'].values[c]
        )
        service_costs.append(transport_cost + df['仓库成本'].values[c])
        service_counts.append(len(served_nodes))

    result['服务总成本'] = service_costs
    result['服务城市数'] = service_counts

    # 5. 显示结果
    print("\n最优配送中心选址方案：")
    print(result[['城市序号', 'x坐标', 'y坐标', '供需量', '仓库成本', '物流系数', '服务总成本', '服务城市数']])
    print(f"\n系统总成本: ¥{best_cost:,.2f}")

    # 6. 执行所有可视化
    plot_convergence(convergence)
    plot_location_map(df, result, dist_matrix)
    plot_radar_chart(result)
    plot_cost_breakdown(result)
    plot_map_with_folium(df, result, dist_matrix)
